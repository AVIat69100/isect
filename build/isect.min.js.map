{"version":3,"file":"isect.min.js","sources":["../node_modules/splaytree/index.js","../src/geom.js","../src/sweepStatus.js","../src/SweepEvent.js","../src/sweep.js","../src/brute.js","../src/createEventQueue.js"],"sourcesContent":["/* follows \"An implementation of top-down splaying\"\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\n */\n\n/**\n * @typedef {*} Key\n */\n\n\n/**\n * @typedef {*} Value\n */\n\n\n/**\n * @typedef {function(node:Node):void} Visitor\n */\n\n\n/**\n * @typedef {function(a:Key, b:Key):number} Comparator\n */\n\n\n/**\n * @param {function(node:Node):string} NodePrinter\n */\n\n\n/**\n * @typedef {Object}  Node\n * @property {Key}    Key\n * @property {Value=} data\n * @property {Node}   left\n * @property {Node}   right\n */\n\nclass Node {\n\n  constructor (key, data) {\n    this.key    = key;\n    this.data   = data;\n    this.left   = null;\n    this.right  = null;\n  }\n}\n\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n\n/**\n * Simple top down splay, not requiring i to be in the tree t.\n * @param {Key} i\n * @param {Node?} t\n * @param {Comparator} comparator\n */\nfunction splay (i, t, comparator) {\n  if (t === null) return t;\n  let l, r, y;\n  const N = new Node();\n  l = r = N;\n\n  while (true) {\n    const cmp = comparator(i, t.key);\n    //if (i < t.key) {\n    if (cmp < 0) {\n      if (t.left === null) break;\n      //if (i < t.left.key) {\n      if (comparator(i, t.left.key) < 0) {\n        y = t.left;                           /* rotate right */\n        t.left = y.right;\n        y.right = t;\n        t = y;\n        if (t.left === null) break;\n      }\n      r.left = t;                               /* link right */\n      r = t;\n      t = t.left;\n    //} else if (i > t.key) {\n    } else if (cmp > 0) {\n      if (t.right === null) break;\n      //if (i > t.right.key) {\n      if (comparator(i, t.right.key) > 0) {\n        y = t.right;                          /* rotate left */\n        t.right = y.left;\n        y.left = t;\n        t = y;\n        if (t.right === null) break;\n      }\n      l.right = t;                              /* link left */\n      l = t;\n      t = t.right;\n    } else {\n      break;\n    }\n  }\n  /* assemble */\n  l.right = t.left;\n  r.left = t.right;\n  t.left = N.right;\n  t.right = N.left;\n  return t;\n}\n\n\n/**\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}      root\n */\nfunction insert (i, data, t, comparator, tree) {\n  const node = new Node(i, data);\n\n  tree._size++;\n\n  if (t === null) {\n    node.left = node.right = null;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp < 0) {\n    node.left = t.left;\n    node.right = t;\n    t.left = null;\n  } else if (cmp >= 0) {\n    node.right = t.right;\n    node.left = t;\n    t.right = null;\n  }\n  return node;\n}\n\n\n/**\n * Insert i into the tree t, unless it's already there.\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}       root\n */\nfunction add (i, data, t, comparator, tree) {\n  const node = new Node(i, data);\n\n  if (t === null) {\n    node.left = node.right = null;\n    tree._size++;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp === 0) return t;\n  else {\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp > 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n    tree._size++;\n    return node;\n  }\n}\n\n\n/**\n * Deletes i from the tree if it's there\n * @param {Key}        i\n * @param {Tree}       tree\n * @param {Comparator} comparator\n * @param {Tree}       tree\n * @return {Node}      new root\n */\nfunction remove (i, t, comparator, tree) {\n  let x;\n  if (t === null) return null;\n  t = splay(i, t, comparator);\n  var cmp = comparator(i, t.key);\n  if (cmp === 0) {               /* found it */\n    if (t.left === null) {\n      x = t.right;\n    } else {\n      x = splay(i, t.left, comparator);\n      x.right = t.right;\n    }\n    tree._size--;\n    return x;\n  }\n  return t;                         /* It wasn't there */\n}\n\n\nfunction split (key, v, comparator) {\n  let left, right;\n  if (v === null) {\n    left = right = null;\n  } else {\n    v = splay(key, v, comparator);\n\n    const cmp = comparator(v.key, key);\n    if (cmp === 0) {\n      left  = v.left;\n      right = v.right;\n    } else if (cmp < 0) {\n      right   = v.right;\n      v.right = null;\n      left    = v;\n    } else {\n      left   = v.left;\n      v.left = null;\n      right  = v;\n    }\n  }\n  return { left, right };\n}\n\n\nfunction merge (left, right, comparator) {\n  if (right === null) return left;\n  if (left  === null) return right;\n\n  right = splay(left.key, right, comparator);\n  right.left = left;\n  return right;\n}\n\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Array<string>}               out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction printRow (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\n`);\n    const indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left)  printRow(root.left,  indent, false, out, printNode);\n    if (root.right) printRow(root.right, indent, true,  out, printNode);\n  }\n}\n\n\nexport default class Tree {\n\n  constructor (comparator = DEFAULT_COMPARE) {\n    this._comparator = comparator;\n    this._root = null;\n    this._size = 0;\n  }\n\n\n  /**\n   * Inserts a key, allows duplicates\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n  insert (key, data) {\n    return this._root = insert(key, data, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * Adds a key, if it is not present in the tree\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n  add (key, data) {\n    return this._root = add(key, data, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  remove (key) {\n    this._root = remove(key, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    let node = this._root;\n    if (node) {\n      while (node.left) node = node.left;\n      this._root = splay(node.key,  this._root, this._comparator);\n      this._root = remove(node.key, this._root, this._comparator, this);\n      return { key: node.key, data: node.data };\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  findStatic (key) {\n    let current   = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0)    return current;\n      else if (cmp < 0) current = current.left;\n      else              current = current.right;\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  find (key) {\n    if (this._root) {\n      this._root = splay(key, this._root, this._comparator);\n      if (this._comparator(key, this._root.key) !== 0) return null;\n    }\n    return this._root;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Boolean}\n   */\n  contains (key) {\n    let current   = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0)    return true;\n      else if (cmp < 0) current = current.left;\n      else              current = current.right;\n    }\n    return false;\n  }\n\n\n  /**\n   * @param  {Visitor} visitor\n   * @param  {*=}      ctx\n   * @return {SplayTree}\n   */\n  forEach (visitor, ctx) {\n    let current = this._root;\n    const Q = [];  /* Initialize stack s */\n    let done = false;\n\n    while (!done) {\n      if (current !==  null) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length !== 0) {\n          current = Q.pop();\n          visitor.call(ctx, current);\n\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range (low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Returns array of keys\n   * @return {Array<Key>}\n   */\n  keys () {\n    const keys = [];\n    this.forEach(({ key }) => keys.push(key));\n    return keys;\n  }\n\n\n  /**\n   * Returns array of all the data in the nodes\n   * @return {Array<Value>}\n   */\n  values () {\n    const values = [];\n    this.forEach(({ data }) => values.push(data));\n    return values;\n  }\n\n\n  /**\n   * @return {Key|null}\n   */\n  min() {\n    if (this._root) return this.minNode(this._root).key;\n    return null;\n  }\n\n\n  /**\n   * @return {Key|null}\n   */\n  max() {\n    if (this._root) return this.maxNode(this._root).key;\n    return null;\n  }\n\n\n  /**\n   * @return {Node|null}\n   */\n  minNode(t = this._root) {\n    if (t) while (t.left) t = t.left;\n    return t;\n  }\n\n\n  /**\n   * @return {Node|null}\n   */\n  maxNode(t = this._root) {\n    if (t) while (t.right) t = t.right;\n    return t;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    let current = this._root, done = false, i = 0;\n    const Q = [];\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = Q.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Node}   d\n   * @return {Node|null}\n   */\n  next (d) {\n    let root = this._root;\n    let successor = null;\n\n    if (d.right) {\n      successor = d.right;\n      while (successor.left) successor = successor.left;\n      return successor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) {\n        successor = root;\n        root = root.left;\n      } else root = root.right;\n    }\n\n    return successor;\n  }\n\n\n  /**\n   * @param  {Node} d\n   * @return {Node|null}\n   */\n  prev (d) {\n    let root = this._root;\n    let predecessor = null;\n\n    if (d.left !== null) {\n      predecessor = d.left;\n      while (predecessor.right) predecessor = predecessor.right;\n      return predecessor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) root = root.left;\n      else {\n        predecessor = root;\n        root = root.right;\n      }\n    }\n    return predecessor;\n  }\n\n\n  /**\n   * @return {SplayTree}\n   */\n  clear() {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n\n  /**\n   * @return {NodeList}\n   */\n  toList() {\n    return toList(this._root);\n  }\n\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param  {Array<Key>}    keys\n   * @param  {Array<Value>}  [values]\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\n   *                                         tree's comparator. Sorting is done\n   *                                         in-place\n   * @return {AVLTree}\n   */\n  load (keys = [], values = [], presort = false) {\n    let size = keys.length;\n    const comparator = this._comparator;\n\n    // sort if needed\n    if (presort) sort(keys, values, 0, size - 1, comparator);\n\n    if (this._root === null) { // empty tree\n      this._root = loadRecursive(this._root, keys, values, 0, size);\n      this._size = size;\n    } else { // that re-builds the whole tree from two in-order traversals\n      const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n      size = this._size + size;\n      this._root = sortedListToBST({ head: mergedList }, 0, size);\n    }\n    return this;\n  }\n\n\n  /**\n   * @return {Boolean}\n   */\n  isEmpty() { return this._root === null; }\n\n  get size () { return this._size; }\n\n\n  /**\n   * @param  {NodePrinter=} printNode\n   * @return {String}\n   */\n  toString (printNode = (n) => n.key) {\n    const out = [];\n    printRow(this._root, '', true, (v) => out.push(v), printNode);\n    return out.join('');\n  }\n\n\n  update (key, newKey, newData) {\n    const comparator = this._comparator;\n    let { left, right } = split(key, this._root, comparator);\n    this._size--;\n    if (comparator(key, newKey) < 0) {\n      right = insert(newKey, newData, right, comparator, this);\n    } else {\n      left = insert(newKey, newData, left, comparator, this);\n    }\n    this._root = merge(left, right, comparator);\n  }\n\n\n  split(key) {\n    return split(key, this._root, this._comparator);\n  }\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction createList(keys, values) {\n  const head = { next: null };\n  let p = head;\n  for (let i = 0; i < keys.length; i++) {\n    p = p.next = { key: keys[i], data: values[i] };\n  }\n  p.next = null;\n  return head.next;\n}\n\n\nfunction toList (root) {\n  var current = root;\n  var Q = [], done = false;\n\n  const head = { next: null };\n  let p = head;\n\n  while (!done) {\n    if (current) {\n      Q.push(current);\n      current = current.left;\n    } else {\n      if (Q.length > 0) {\n        current = p = p.next = Q.pop();\n        current = current.right;\n      } else done = true;\n    }\n  }\n  p.next = null; // that'll work even if the tree was empty\n  return head.next;\n}\n\n\nfunction sortedListToBST(list, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const left = sortedListToBST(list, start, middle);\n\n    const root = list.head;\n    root.left = left;\n\n    list.head = list.head.next;\n\n    root.right = sortedListToBST(list, middle + 1, end);\n    return root;\n  }\n  return null;\n}\n\n\nfunction mergeLists (l1, l2, compare = (a, b) => a - b) {\n  const head = {}; // dummy\n  let p = head;\n\n  let p1 = l1;\n  let p2 = l2;\n\n  while (p1 !== null && p2 !== null) {\n    if (compare(p1.key, p2.key) < 0) {\n      p.next = p1;\n      p1 = p1.next;\n    } else {\n      p.next = p2;\n      p2 = p2.next;\n    }\n    p = p.next;\n  }\n\n  if (p1 !== null)      p.next = p1;\n  else if (p2 !== null) p.next = p2;\n\n  return head.next;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n","/**\n * Just a collection of geometry related utilities\n */\n\n// This is used for precision checking (e.g. two numbers are equal\n// if their difference is smaller than this number). The value is \n// chosen empirically. We still may run into precision related issues.\n// TODO: we should allow consumers to configure this.\nexport const EPS = 1e-9;//10;\n\nexport function getIntersectionXPoint(segment, xPos, yPos) {\n  var dy1 = segment.from.y - yPos;\n  var dy2 = yPos - segment.to.y;\n  var dy = segment.to.y - segment.from.y;\n  if (Math.abs(dy1) < EPS) {\n    // The segment starts on the sweep line\n    if (Math.abs(dy) < EPS) {\n      // the segment is horizontal. Intersection is at the point\n      if (xPos <= segment.from.x) return segment.from.x;\n      if (xPos > segment.to.x) return segment.to.x;\n      return xPos;\n    }\n    return segment.from.x;\n  }\n  \n  var dx = (segment.to.x - segment.from.x); \n  var xOffset; \n  if (dy1 >= dy2) {\n    xOffset = dy1 * (dx / dy); \n    return (segment.from.x - xOffset);\n  } \n  xOffset = dy2 * (dx / dy);\n  return (segment.to.x + xOffset);\n}\n\nexport function angle(dx, dy) {\n  // https://stackoverflow.com/questions/16542042/fastest-way-to-sort-vectors-by-angle-without-actually-computing-that-angle\n  var p = dx/(Math.abs(dx) + Math.abs(dy)) // -1 .. 1 increasing with x\n\n  if (dy < 0) return p - 1;  // -2 .. 0 increasing with x\n  return 1 - p               //  0 .. 2 decreasing with x\n}\n\nexport function intersectSegments(a, b) {\n  //  https://stackoverflow.com/a/1968345/125351\n  var aStart = a.from, bStart = b.from;\n  var p0_x = aStart.x, p0_y = aStart.y,\n      p2_x = bStart.x, p2_y = bStart.y;\n\n  var s1_x = a.dx, s1_y = a.dy, s2_x = b.dx, s2_y = b.dy;\n  var div = s1_x * s2_y - s2_x * s1_y;\n\n  var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;\n  if (s < 0 || s > 1) return;\n\n  var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;\n\n  if (t >= 0 && t <= 1) {\n    return {\n      x: p0_x - (t * s1_x),\n      y: p0_y - (t * s1_y)\n    }\n  }\n}\n\nexport function same(x0, x1, y0, y1) {\n  return Math.abs(x0 - x1) < EPS && Math.abs(y0 - y1) < EPS;\n}\n\nexport function samePoint(a, b) {\n  return Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS;\n}\n","import SplayTree from 'splaytree';\nimport {samePoint, getIntersectionXPoint} from './geom'\n\n/**\n * Creates a new sweep status data structure.\n */\nexport default function createSweepStatus(onError, EPS) {\n  var lastPointY, prevY;\n  var lastPointX, prevX;\n  var useBelow = false;\n  var status = new SplayTree(compareSegments);\n\n  // To save on GC we return mutable object.\n  var currentBoundary = {\n    beforeLeft: null,\n    left: null,\n    right: null,\n    afterRight: null,\n  }\n\n  var currentLeftRight = {left: null, right: null};\n\n  return {\n    /**\n     * Add new segments into the status tree.\n     */\n    insertSegments,\n\n    /**\n     * Remove segments from the status tree.\n     */\n    deleteSegments,\n\n    /**\n     * Returns segments that are to the left and right from a given point.\n     */\n    getLeftRightPoint,\n\n    /**\n     * For a given collections of segments finds the most left and the most right\n     * segments. Also returns segments immediately before left, and after right segments.\n     */\n    getBoundarySegments,\n\n    findSegmentsWithPoint,\n\n    /**\n     * Current binary search tree with segments\n     */\n    status,\n\n    /**\n     * Introspection method that verifies if there are duplicates in the segment tree.\n     * If there are - `onError()` is called.\n     */\n    checkDuplicate,\n\n    /**\n     * Prints current segments in order of their intersection with sweep line. Introspection method.\n     */\n    printStatus,\n\n    /**\n     * Returns current position of the sweep line.\n     */\n    getLastPoint() {\n      return {x: lastPointX, y: lastPointY};\n    }\n  }\n\n  function compareSegments(a, b) {\n    if (a === b) return 0;\n\n    var ak = getIntersectionXPoint(a, lastPointX, lastPointY);\n    var bk = getIntersectionXPoint(b, lastPointX, lastPointY);\n\n    var res = ak - bk;\n    if (Math.abs(res) >= EPS) {\n      // We are okay fine. Intersection distance between two segments\n      // is good to give conclusive answer\n      return res;\n    }\n\n    var aIsHorizontal = Math.abs(a.dy) < EPS;\n    var bIsHorizontal = Math.abs(b.dy) < EPS;\n    if (aIsHorizontal && bIsHorizontal) {\n      return b.to.x - a.to.x;\n    }\n    // TODO: What if both a and b is horizontal?\n    // move horizontal to end\n    if (aIsHorizontal) { \n      return useBelow ? -1 : 1;\n    }\n\n    if (bIsHorizontal) {\n      if (useBelow) {\n        return (b.from.x >= lastPointX) ? -1 : 1\n      }\n      return -1;\n      // return useBelow ? 1 : -1;\n    }\n    var pa = a.angle;\n    var pb = b.angle;\n    if (Math.abs(pa - pb) >= EPS) {\n      return useBelow ? pa - pb : pb - pa;\n    }\n\n    var segDist = a.from.y - b.from.y;\n    if (Math.abs(segDist) >= EPS) {\n      return -segDist;\n    }\n    segDist = a.to.y - b.to.y;\n    if (Math.abs(segDist) >= EPS) {\n      // TODO: Is this accurate?\n      return -segDist;\n    }\n\n    return 0;\n    // Could also use:\n    // var aAngle = Math.atan2(a.from.y - a.to.y, a.from.x - a.to.x);\n    // var bAngle = Math.atan2(b.from.y - b.to.y, b.from.x - b.to.x);\n    // return useBelow ? bAngle - aAngle : aAngle - bAngle;\n  }\n\n  function getBoundarySegments(upper, interior) {\n    var leftMost, rightMost, i;\n    var uLength = upper.length;\n\n    if (uLength > 0) {\n      leftMost = rightMost = upper[0];\n    } else {\n      leftMost = rightMost = interior[0];\n    }\n\n    for (i = 1; i < uLength; ++i) {\n      var s = upper[i];\n      var cmp = compareSegments(leftMost, s);\n      if (cmp > 0) leftMost = s;\n\n      cmp = compareSegments(rightMost, s);\n      if (cmp < 0) rightMost = s;\n    }\n\n    var startFrom = uLength > 0 ? 0 : 1;\n    for (i = startFrom; i < interior.length; ++i) {\n      s = interior[i];\n      cmp = compareSegments(leftMost, s);\n      if (cmp > 0) leftMost = s;\n\n      cmp = compareSegments(rightMost, s);\n      if (cmp < 0) rightMost = s;\n    }\n\n    // at this point we have our left/right segments in the status.\n    // Let's find their prev/next elements and report them back:\n    var left = status.find(leftMost);\n    if (!left) {\n      onError('Left is missing. Precision error?');\n    }\n\n    var right = status.find(rightMost);\n    if (!right) {\n      onError('Right is missing. Precision error?');\n    }\n\n    var beforeLeft = left && status.prev(left);\n    var afterRight = right && status.next(right);\n\n    while (afterRight && right.key.dy === 0 && afterRight.key.dy === 0) {\n      // horizontal segments are special :(\n      afterRight = status.next(afterRight);\n    }\n\n    currentBoundary.beforeLeft = beforeLeft && beforeLeft.key;\n    currentBoundary.left = left && left.key;\n    currentBoundary.right = right && right.key;\n    currentBoundary.afterRight = afterRight && afterRight.key;\n\n    return currentBoundary;\n  }\n\n  function getLeftRightPoint(p) {\n    // We are trying to find left and right segments that are nearest to the\n    // point p. For this we traverse the binary search tree, and remember\n    // node with the shortest distance to p.\n    var lastLeft;\n    var current = status._root;\n    var minX = Number.POSITIVE_INFINITY;\n\n    var useNext = false;\n    while (current) {\n      var x = getIntersectionXPoint(current.key, p.x, p.y);\n      var dx = p.x - x;\n      if (dx >= 0) {\n        if (dx < minX) {\n          minX = dx;\n          lastLeft = current;\n          current = current.left;\n          useNext = false;\n        } else {\n          break;\n        }\n      } else {\n        if (-dx < minX) {\n          useNext = true;\n          minX = -dx;\n          lastLeft = current;\n          current = current.right;\n        } else {\n          break;\n        }\n      }\n    }\n    if (useNext) {\n      // I'm not sure why I did this. I don't this this is right now.\n      // lastLeft = status.next(lastLeft);\n    }\n\n    currentLeftRight.left = lastLeft && lastLeft.key\n    var next = lastLeft && status.next(lastLeft);\n    currentLeftRight.right = next && next.key\n    return currentLeftRight;\n\n    // Conceptually, the code above should be equivalent to the code below;\n    // The code below is easier to understand, but intuitively, the code above\n    // should have better performance (as we do not traverse the entire status\n    // tree)\n\n    // var right, left,  x;\n    // var all = status.keys()\n    // for (var i = 0; i < all.length; ++i) {\n    //   var segment = all[i];\n    //   x = getIntersectionXPoint(segment, p.x, p.y);\n    //   if (x > p.x && !right) {\n    //     right = segment;\n    //     break;\n    //   } else if (x < p.x) {\n    //     left = segment;\n    //   }\n    // }\n\n    // currentLeftRight.left = left;\n    // currentLeftRight.right = right;\n\n    // return currentLeftRight;\n  }\n\n  function findSegmentsWithPoint(p, onFound) {\n    // Option 1.\n    // var arrResults = [];\n    // status.forEach(current => {\n    //   var x = getIntersectionXPoint(current.key, p.x, p.y);\n    //   var dx = p.x - x;\n    //   if (Math.abs(dx) < EPS) {\n    //     onFound(current.key);\n    //    // arrResults.push(current.key)\n    //   }\n    // });\n    // return arrResults;\n\n    // Option 2.\n\n    // let current = status._root;\n    // const Q = [];  /* Initialize stack s */\n    // let done = false;\n    // var res = [];\n    // var breakEarly = false;\n\n    // while (!done) {\n    //   if (current !==  null) {\n    //     Q.push(current);\n    //     current = current.left;\n    //   } else {\n    //     if (Q.length !== 0) {\n    //       current = Q.pop();\n\n    //       var x = getIntersectionXPoint(current.key, p.x, p.y);\n    //       var dx = p.x - x;\n    //       if (Math.abs(dx) < EPS) {\n    //         res.push(current.key)\n    //         breakEarly = true;\n    //       } else if (breakEarly) {\n    //         done = true;\n    //       }\n\n    //       current = current.right;\n    //     } else done = true;\n    //   }\n    // }\n\n    // return res;\n\n    // option 3.\n    var current = status._root;\n\n    while (current) {\n      var x = getIntersectionXPoint(current.key, p.x, p.y);\n      var dx = p.x - x;\n      if (Math.abs(dx) < EPS) {\n        collectAdjacentNodes(current, p, onFound);\n        break;\n      } else if (dx < 0) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n  }\n\n  function collectAdjacentNodes(root, p, onFound) {\n    onFound(root.key);\n    goOverPredecessors(root.left, p, onFound);\n    goOverSuccessors(root.right, p, onFound);\n  }\n\n  function goOverPredecessors(root, p, res) {\n    if (!root) return;\n    var x = getIntersectionXPoint(root.key, p.x, p.y);\n    var dx = p.x - x;\n    if (Math.abs(dx) < EPS) {\n      collectAdjacentNodes(root, p, res);\n    } else {\n      goOverPredecessors(root.right, p, res);\n    }\n  }\n\n  function goOverSuccessors(root, p, res) {\n    if (!root) return;\n    var x = getIntersectionXPoint(root.key, p.x, p.y);\n    var dx = p.x - x;\n    if (Math.abs(dx) < EPS) {\n      collectAdjacentNodes(root, p, res);\n    } else {\n      goOverSuccessors(root.left, p, res);\n    }\n  }\n\n  function checkDuplicate() {\n    var prev;\n    status.forEach(node => {\n      var current = node.key;\n\n      if (prev) {\n        if (samePoint(prev.from, current.from) && samePoint(prev.to, current.to)) {\n          // Likely you have received error before during segment removal.\n          onError('Duplicate key in the status! This may be caused by Floating Point rounding error')\n        }\n      }\n      prev = current;\n    });\n  }\n\n  function printStatus(prefix = '') {\n    // eslint-disable-next-line\n    console.log(prefix, 'status line: ', lastPointX, lastPointY);\n    status.forEach(node => {\n      var x = getIntersectionXPoint(node.key, lastPointX, lastPointY);\n      // eslint-disable-next-line\n      console.log(x + ' ' + node.key.name);\n    })\n  }\n\n  function insertSegments(interior, upper, sweepLinePos) {\n    lastPointY = sweepLinePos.y;\n    lastPointX = sweepLinePos.x;\n    var key;\n\n    for (var i = 0; i < interior.length; ++i) {\n      key = interior[i];\n      status.add(key);\n    }\n    for (i = 0; i < upper.length; ++i) {\n      key = upper[i]\n      status.add(key);\n    }\n  }\n\n  function deleteSegments(lower, interior, sweepLinePos) {\n    // I spent most of the time debugging this method. Depending on the\n    // algorithm state we can run into situation when dynamic keys of the\n    // `status` tree predict wrong branch, and thus we are not able to find\n    // the segment that needs to be deleted. If that happens I'm trying to\n    // use previous point and repeat the process. This may result in \n    // incorrect state. In that case I report an error. \n    var i;\n    var prevCount = status._size;\n    prevX = lastPointX;\n    prevY = lastPointY;\n    lastPointY = sweepLinePos.y;\n    lastPointX = sweepLinePos.x;\n\n    useBelow = true;\n    for(i = 0; i < lower.length; ++i) {\n      removeSegment(lower[i], sweepLinePos)\n    }\n    for(i = 0; i < interior.length; ++i) {\n      removeSegment(interior[i], sweepLinePos)\n    }\n    useBelow = false;\n\n    if (status._size !== prevCount - interior.length - lower.length) {\n      // This can happen when rounding error occurs. You can try scaling your input\n      onError('Segments were not removed from a tree properly. Precision error?');\n    }\n  }\n\n  function removeSegment(key, sweepLinePos) {\n    if (status.find(key)) {\n      status.remove(key);\n    } else {\n      lastPointX = prevX;\n      lastPointY = prevY;\n      if (status.find(key)) {\n        status.remove(key);\n      } else {\n        // They will get an error :(\n      }\n      lastPointY = sweepLinePos.y;\n      lastPointX = sweepLinePos.x;\n    }\n  }\n}","/**\n * Represents a single event in the sweep-line algorithm\n */\nexport default class SweepEvent {\n  /**\n   * Creates new sweep event of a given kind.\n   */\n  constructor(point, segment) {\n    this.point = point;\n    if (segment) this.from = [segment];\n  }\n}\n","import createEventQueue from './createEventQueue';\nimport createSweepStatus from './sweepStatus';\nimport SweepEvent from './SweepEvent';\n\nimport {intersectSegments, EPS, angle, samePoint} from './geom';\n\n/**\n * A point on a line\n * \n * @typedef {Object} Point\n * @property {number} x coordinate\n * @property {number} y coordinate\n */\n\n\n/**\n * @typedef {Object} Segment \n * @property {Point} from start of the segment\n * @property {Point} to end of the segment\n */\n\n/**\n * @typedef {function(point : Point, interior : Segment[], lower : Segment[], upper : Segment[])} ReportIntersectionCallback\n */\n\n/**\n * @typedef {Object} ISectOptions \n * @property {ReportIntersectionCallback} onFound \n */\n\n /**\n  * @typedef {Object} ISectResult\n  */\n\n// We use EMPTY array to avoid pressure on garbage collector. Need to be\n// very cautious to not mutate this array.\nvar EMPTY = [];\n\n/**\n * Finds all intersections among given segments.\n * \n * The algorithm follows \"Computation Geometry, Algorithms and Applications\" book\n * by Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars.\n * \n * Line is swept top-down\n * \n * @param {Segment[]} segments\n * @param {ISectOptions=} options\n * @returns {ISectResult}\n */\nexport default function isect(segments, options) {\n  var results = [];\n  var reportIntersection = (options && options.onFound) || defaultIntersectionReporter;\n\n  var onError = (options && options.onError) || defaultErrorReporter;\n\n  var eventQueue = createEventQueue(byY);\n  var sweepStatus = createSweepStatus(onError, EPS);\n  var lower, interior, lastPoint;\n\n  segments.forEach(addSegment);\n\n  return {\n    /**\n     * Find all intersections synchronously.\n     * \n     * @returns array of found intersections.\n     */\n    run,\n\n    /**\n     * Performs a single step in the sweep line algorithm\n     * \n     * @returns true if there was something to process; False if no more work to do\n     */\n    step,\n\n    // Methods below are low level API for fine-grained control.\n    // Don't use it unless you understand this code thoroughly\n\n    /**\n     * Add segment into the \n     */\n    addSegment,\n\n    /**\n     * Direct access to event queue. Queue contains segment endpoints and\n     * pending detected intersections.\n     */\n    eventQueue, \n\n    /**\n     * Direct access to sweep line status. \"Status\" holds information about\n     * all intersected segments.\n     */\n    sweepStatus,\n\n    /**\n     * Access to results array. Works only when you use default onFound() handler\n     */\n    results\n  }\n\n  function run() {\n    while (!eventQueue.isEmpty()) {\n      var eventPoint = eventQueue.pop();\n      if (handleEventPoint(eventPoint)) {\n        // they decided to stop.\n        return;\n      };\n    }\n\n    return results;\n  }\n\n  function step() {\n    if (!eventQueue.isEmpty()) {\n      var eventPoint = eventQueue.pop();\n      handleEventPoint(eventPoint);\n      // Note: we don't check results of `handleEventPoint()`\n      // assumption is that client controls `step()` and thus they \n      // know better if they want to stop.\n      return true;\n    }\n    return false;\n  }\n\n  function handleEventPoint(p) {\n    lastPoint = p.point;\n    var upper = p.from || EMPTY;\n\n    lower = interior = undefined;\n    // TODO: move lower/interior into sweep status method?\n\n    sweepStatus.findSegmentsWithPoint(lastPoint, addLowerOrInterior);\n    // if (segmentsWithPoint) {\n    //   segmentsWithPoint.forEach()\n    // } \n\n    if (!lower) lower = EMPTY;\n    if (!interior) interior = EMPTY;\n\n    var uLength = upper.length;\n    var iLength = interior.length;\n    var lLength = lower.length;\n    var hasIntersection = uLength + iLength + lLength > 1;\n    var hasPointIntersection = !hasIntersection && (uLength === 0 && lLength === 0 && iLength > 0);\n\n    if (hasIntersection || hasPointIntersection) {\n      p.isReported = true;\n      if (reportIntersection(lastPoint, interior, lower, upper)) {\n        return true;\n      }\n    }\n\n    sweepStatus.deleteSegments(lower, interior, lastPoint);\n    sweepStatus.insertSegments(interior, upper, lastPoint);\n\n    var sLeft, sRight;\n\n    var hasNoCrossing = (uLength + iLength === 0);\n\n    if (hasNoCrossing) {\n      var leftRight = sweepStatus.getLeftRightPoint(lastPoint);\n      sLeft = leftRight.left;\n      if (!sLeft) return;\n\n      sRight = leftRight.right;\n      if (!sRight) return;\n\n      findNewEvent(sLeft, sRight, p);\n    } else {\n      var boundarySegments = sweepStatus.getBoundarySegments(upper, interior);\n\n      findNewEvent(boundarySegments.beforeLeft, boundarySegments.left, p);\n      findNewEvent(boundarySegments.right, boundarySegments.afterRight, p);\n    }\n\n    return false;\n  }\n\n  function addLowerOrInterior(s) {\n    if (samePoint(s.to, lastPoint)) {\n      if (!lower) lower = [s];\n      else lower.push(s);\n    } else if (!samePoint(s.from, lastPoint)) {\n      if (!interior) interior = [s];\n      else interior.push(s);\n    }\n  }\n\n  function findNewEvent(left, right, p) {\n    if (!left || !right) return;\n\n    var intersection = intersectSegments(left, right);\n    if (!intersection) {\n        return;\n    }\n\n    var dy = p.point.y - intersection.y\n    // TODO: should I add dy to intersection.y?\n    if (dy < -EPS) {\n      // this means intersection happened after the sweep line. \n      // We already processed it.\n      return;\n    }\n    if (Math.abs(dy) < EPS && intersection.x <= p.point.x) {\n      return;\n    }\n\n    // Need to adjust floating point for this special case,\n    // since otherwise it gives rounding errors:\n    roundNearZero(intersection);\n\n    var current = eventQueue.find(intersection);\n\n    if (current && current.isReported) {\n      // We already reported this event. No need to add it one more time\n      // TODO: Is this case even possible?\n      onError('We already reported this event.');\n      return;\n    }\n\n    if (!current) {\n      var event = new SweepEvent(intersection)\n      eventQueue.insert(event);\n    }\n  }\n\n  function defaultIntersectionReporter(p, interior, lower, upper) {\n    results.push({\n      point: p, \n      segments: union(union(interior, lower), upper)\n    });\n  }\n\n  function addSegment(segment) {\n    var from = segment.from;\n    var to = segment.to;\n\n    // Small numbers give more precision errors. Rounding them to 0.\n    roundNearZero(from);\n    roundNearZero(to);\n\n    var dy = from.y - to.y;\n\n    // Note: dy is much smaller then EPS on purpose. I found that higher\n    // precision here does less good - getting way more rounding errors.\n    if (Math.abs(dy) < 1e-5) {\n      from.y = to.y;\n      segment.dy = 0;\n    }\n    if ((from.y < to.y) || (\n        (from.y === to.y) && (from.x > to.x))\n      ) {\n      var temp = from;\n      from = segment.from = to; \n      to = segment.to = temp;\n    }\n\n    // We pre-compute some immutable properties of the segment\n    // They are used quite often in the tree traversal, and pre-computation\n    // gives significant boost:\n    segment.dy = from.y - to.y;\n    segment.dx = from.x - to.x;\n    segment.angle = angle(segment.dy, segment.dx);\n\n    var isPoint = segment.dy === segment.dx && segment.dy === 0;\n    var prev = eventQueue.find(from)\n    if (prev && !isPoint) {\n      // this detects identical segments early. Without this check\n      // the algorithm would break since sweep line has no means to\n      // detect identical segments.\n      var prevFrom = prev.data.from;\n      if (prevFrom) {\n        for (var i = 0; i < prevFrom.length; ++i) {\n          var s = prevFrom[i];\n          if (samePoint(s.to, to)) {\n            reportIntersection(s.from, [], s.from, s.to);\n            reportIntersection(s.to, [], s.from, s.to);\n            return;\n          }\n        }\n      }\n    }\n\n    if (!isPoint) {\n      if (prev) {\n        if (prev.data.from) prev.data.from.push(segment);\n        else prev.data.from = [segment];\n      } else {\n        var e = new SweepEvent(from, segment)\n        eventQueue.insert(e);\n      }\n      var event = new SweepEvent(to)\n      eventQueue.insert(event)\n    } else {\n      var event = new SweepEvent(to)\n      eventQueue.insert(event)\n    }\n  } \n}\n\nfunction roundNearZero(point) {\n  if (Math.abs(point.x) < EPS) point.x = 0;\n  if (Math.abs(point.y) < EPS) point.y = 0;\n}\n\nfunction defaultErrorReporter(errorMessage) {\n  throw new Error(errorMessage);\n}\n\nfunction union(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n\n  return a.concat(b);\n}\n\nfunction byY(a, b) {\n  // decreasing Y \n  var res = b.y - a.y;\n  // TODO: This might mess up the status tree.\n  if (Math.abs(res) < EPS) {\n    // increasing x.\n    res = a.x - b.x;\n    if (Math.abs(res) < EPS) res = 0;\n  }\n\n  return res;\n}","/**\n * This is a brute force solution with O(n^2) performance.\n * (`n` is number of segments).\n * \n * Use this when number of lines is low, and number of intersections\n * is high.\n */\n\nexport default function brute(lines, options) {\n  var results = [];\n  var reportIntersection = (options && options.onFound) || \n                            defaultIntersectionReporter;\n  var asyncState;\n\n  return {\n    /**\n     * Execute brute force of the segment intersection search\n     */\n    run,\n    /**\n     * Access to results array. Works only when you use default onFound() handler\n     */\n    results,\n\n    /**\n     * Performs a single step in the brute force algorithm ()\n     */\n    step\n  }\n\n  function step() {\n    if (!asyncState) {\n      asyncState = {\n        i: 0\n      }\n    }\n    var test = lines[asyncState.i];\n    for (var j = asyncState.i + 1; j < lines.length; ++j) {\n      var other = lines[j];\n      var pt = intersectSegments(test, other);\n      if (pt) {\n        if (reportIntersection(pt, [test, other])) {\n          return;\n        }\n      }\n    }\n    asyncState.i += 1;\n    return asyncState.i < lines.length;\n  }\n\n  function run() {\n    for(var i = 0; i < lines.length; ++i) {\n      var test = lines[i];\n      for (var j = i + 1; j < lines.length; ++j) {\n        var other = lines[j];\n        var pt = intersectSegments(test, other);\n        if (pt) {\n          if (reportIntersection(pt, [test, other])) {\n            return;\n          }\n        }\n      }\n    }\n    return results;\n  }\n\n  function defaultIntersectionReporter(p, interior) {\n    results.push({\n      point: p, \n      segments: interior\n    });\n  }\n}\n\nfunction intersectSegments(a, b) {\n  //  https://stackoverflow.com/a/1968345/125351\n  var aStart = a.from, bStart = b.from;\n  var p0_x = aStart.x, p0_y = aStart.y,\n      p2_x = bStart.x, p2_y = bStart.y;\n\n  var s1_x = a.from.x - a.to.x, s1_y = a.from.y - a.to.y, s2_x = b.from.x - b.to.x, s2_y = b.from.y - b.to.y;\n  var div = s1_x * s2_y - s2_x * s1_y;\n\n  var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;\n  if (s < 0 || s > 1) return;\n\n  var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;\n\n  if (t >= 0 && t <= 1) {\n    return {\n      x: p0_x - (t * s1_x),\n      y: p0_y - (t * s1_y)\n    }\n  }\n}\n","import SplayTree from 'splaytree';\n\nexport default function createEventQueue(byY) {\n  const q = new SplayTree(byY);\n\n  return {\n    isEmpty: isEmpty,\n    size: size,\n    pop: pop,\n    find: find,\n    insert: insert\n  }\n\n  function find(p) {\n    return q.find(p);\n  }\n\n  function size() {\n    return q.size;\n  }\n\n  function isEmpty() {\n    return q.isEmpty();\n  }\n\n  function insert(event) {\n    // debugger;\n    q.add(event.point, event);\n  }\n\n  function pop() {\n    var node = q.pop();\n    return node && node.data;\n  }\n}\n"],"names":["Node","key","data","this","left","right","DEFAULT_COMPARE","a","b","splay","i","t","comparator","let","l","r","y","N","const","cmp","insert","tree","node","_size","remove","x","split","v","Tree","_comparator","_root","add","pop","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","done","push","length","call","range","low","high","fn","keys","ref","values","min","minNode","max","maxNode","at","index","next","d","root","successor","prev","predecessor","clear","toList","head","p","load","presort","size","sort","pivot","j","tmp","loadRecursive","parent","start","end","middle","Math","floor","mergedList","l1","l2","p1","p2","mergeLists","createList","sortedListToBST","list","isEmpty","prototypeAccessors","toString","printNode","n","out","printRow","prefix","isTail","indent","join","update","newKey","newData","EPS","getIntersectionXPoint","segment","xPos","yPos","dy1","from","dy2","to","dy","abs","xOffset","dx","samePoint","createSweepStatus","onError","lastPointY","prevY","lastPointX","prevX","useBelow","status","SplayTree","compareSegments","currentBoundary","beforeLeft","afterRight","currentLeftRight","interior","upper","sweepLinePos","lower","prevCount","removeSegment","lastLeft","minX","Number","POSITIVE_INFINITY","leftMost","rightMost","uLength","s","onFound","collectAdjacentNodes","console","log","name","getLastPoint","res","aIsHorizontal","bIsHorizontal","pa","angle","pb","segDist","goOverPredecessors","goOverSuccessors","SweepEvent","point","EMPTY","roundNearZero","defaultErrorReporter","errorMessage","Error","union","concat","byY","intersectSegments","aStart","bStart","p0_x","p0_y","p2_x","p2_y","s1_x","s1_y","s2_x","s2_y","div","segments","options","q","lastPoint","results","reportIntersection","eventQueue","event","sweepStatus","addSegment","eventPoint","handleEventPoint","undefined","findSegmentsWithPoint","addLowerOrInterior","sLeft","sRight","iLength","lLength","hasIntersection","isReported","deleteSegments","insertSegments","leftRight","getLeftRightPoint","findNewEvent","boundarySegments","getBoundarySegments","intersection","temp","isPoint","prevFrom","e","lines","asyncState","test","other","pt"],"mappings":"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"}